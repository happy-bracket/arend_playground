\import Data.Bool
\import Data.List
\import Logic
\open Nat

\data MyNat
  | z
  | s MyNat

\func if {A : \Type} (b : Bool) (t f : A) : A \elim b
  | true => t
  | false => f

\func or' (l r : Bool) : Bool => if l l (if r r false)

\func \infixr 8 ^ (b exp : Nat) =>  ^' 1 b exp
  \where
    \func ^' (acc b exp : Nat) : Nat \elim exp
      | 0 => acc
      | (suc n) => ^' (acc * b) b n

\func fac (x : Nat) : Nat
  | 0 => 1
  | (suc n) => (suc n) * fac n

\func map {A B : \Type} (_ : A -> B) (_ : List A) : List B
  | _, nil => nil
  | f, (:: a as) => (f a) :: map f as


\func curry {P Q R : \Type} (f : \Sigma P Q -> R) (p : P) (q : Q) : R => f (p, q)
\func uncurry {P Q R : \Type} (f : P -> Q -> R) (pq : \Sigma P Q) : R => f pq.1 pq.2

\data \infixr 2 || (P Q : \Type)
  | inl P
  | inr Q

\func ||-elim {P Q R : \Type} (l : P -> R) (r : Q -> R) (e : P || Q) : R \elim e
  | inl p => l p
  | inr q => r q

\func binaryModusPonens {P Q R : \Type} (pqr : P -> Q -> R) (pq : P -> Q) (p : P) : R => pqr p (pq p)

\func pqrp=>pr=>r {P Q R : \Type} (pqrp : (P -> Q -> R) -> P) (pr : P -> R) : R => pr (pqrp (\lam p _ => pr p))

\func forallA_Pa=>EA_Pa {A : \Type} {P : A -> \Type} (a : A) (fa : \Pi (x : A) -> P x) : \Sigma (x : A) (P x) => (a, fa a)

\func forallNat_NotPn=>P3_Empty {P : Nat -> \Type} (fa : \Pi (x : Nat) -> Not (P x)) : Not (P 3) => fa 3

\func Px->Qx&ENat_Px=>ENat_Qx
  {P Q : Nat -> \Type}
  (fa : \Pi (x : Nat) -> (P x -> Q x))
  (e : \Sigma (x : Nat) (P x))
  : \Sigma (x : Nat) (Q x) => (e.1, (fa e.1) e.2)

\func and-isAssociative (x y z : Bool) : (x and y) and z = x and (y and z)
  | false, _, _ => idp
  | true, false, _ => idp
  | true, true, false => idp
  | true, true, true => idp

\func or-isAssociative (x y z : Bool) : (x or y) or z = x or (y or z)
  | true, _, _ => idp
  | false, true, _ => idp
  | false, false, true => idp
  | false, false, false => idp

\func twoTimesTwoIsFour : 2 * 2 = 4 => idp
